

This algorithm looks through both list I and j
and checks whether I is not equal to j and whether list[i] is equal to list [j]
if they are, then the list has a duplicate within it and the code returns
true.  If there is not a duplicate, then
it will return false and end the procedure.
 
Quadratic will have the worst running time
because the algorithm must check data in each list to see if there is a
duplicate this will quadruple the amount of time that it will take for the
program to finish.
 
 
The algorithm, is still correct because the code
checks the previous items in the list with the new item meaning that once the
code has completed it will have compared the items but not have made any
duplicate comparisons.
 
The algorithm runs twice as fast because it only
has to run half the comparisons after taking away the duplicate comparisons.
 
 
I
 
O (n log n)
 
 
O(n)
 
The faster algorithm to run would be O (n log n)
because O(n) is linear meaning that the function is proportional to the size of
the list. Whereas O (n log n) will only take a few iterations because it halves
the list, instead of checking each item in the list against each other.
 
 











































 


